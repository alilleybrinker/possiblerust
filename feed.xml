<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-22T18:55:39-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Possible Rust</title><subtitle>Learning what&amp;rsquo;s possible in Rust.</subtitle><author><name>{&quot;picture&quot;=&gt;&quot;/assets/img/me.png&quot;, &quot;twitter&quot;=&gt;&quot;alilleybrinker&quot;}</name></author><entry><title type="html">Rust Lints You May Not Know</title><link href="http://localhost:4000/pattern/rust-lints-you-may-not-know" rel="alternate" type="text/html" title="Rust Lints You May Not Know" /><published>2020-06-21T15:59:00-07:00</published><updated>2020-06-21T15:59:00-07:00</updated><id>http://localhost:4000/pattern/rust-lints-you-may-not-know</id><content type="html" xml:base="http://localhost:4000/pattern/rust-lints-you-may-not-know">&lt;p&gt;The Rust compiler ships with a number of useful lints on by default,
and many use Clippy to provide additional lints. It’s less well known
that the Rust compiler ships with some useful lints which are set to
&lt;code class=&quot;highlighter-rouge&quot;&gt;allow&lt;/code&gt; by default, meaning they don’t generate warnings. In this post,
I’ll explain what each of these lints does, and why it might be useful.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;where-to-find-these-lints&quot;&gt;Where to Find These Lints&lt;/h2&gt;

&lt;p&gt;The lists of “allowed-by-default” lints can be found in the &lt;a href=&quot;https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html&quot; title=&quot;List of allowed-by-default lints&quot;&gt;“Rustc book,”&lt;/a&gt;
a guide to the Rust compiler produced by the Rust team. This page does a good
job of explaining what the lints are, how to turn them on, and what effect they have
on your code. What it doesn’t do is explain why these lints are present, or why they
are turned off by default.&lt;/p&gt;

&lt;p&gt;For code examples for each of these lints, refer to the Rustc Book.&lt;/p&gt;

&lt;h2 id=&quot;the-lints&quot;&gt;The Lints&lt;/h2&gt;

&lt;h3 id=&quot;anonymous-parameters&quot;&gt;Anonymous Parameters&lt;/h3&gt;

&lt;p&gt;Rust 2015 allowed parameter names to be omitted in trait definitions, in a manner
similar to the ability in C or C++ to omit parameter names for function prototypes
in header files. However, it was considered poor style, and support for it was
removed with Rust 2018.&lt;/p&gt;

&lt;p&gt;Resolving this lint is easy. If you don’t want to have to name the parameters, you can
use the name &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;, which is Rust’s standard name for ignoring values. However, the
purpose of this lint is to encourage you to provide useful, meaningful names for the
parameters.&lt;/p&gt;

&lt;h3 id=&quot;box-pointers&quot;&gt;Box Pointers&lt;/h3&gt;

&lt;p&gt;Before Rust offered a mechanism to change the default allocator, one had to implement
their own version of &lt;code class=&quot;highlighter-rouge&quot;&gt;Box&lt;/code&gt; which used a different underying allocator. In that situation,
it was desirable for the compiler to flag if you still used the standard &lt;code class=&quot;highlighter-rouge&quot;&gt;Box&lt;/code&gt; type, as
that would &lt;em&gt;not&lt;/em&gt; use the custom allocator you intended.&lt;/p&gt;

&lt;p&gt;Today, Rust programs can freely change the default allocator, removing the common need
for this lint. Otherwise, it’s useful if you wish to disallow heap allocation, although
there remain other types (like &lt;code class=&quot;highlighter-rouge&quot;&gt;Vec&lt;/code&gt;) which allocate data on the heap, so this lint would
be useful, but not sufficient, for ensuring no heap allocations occur.&lt;/p&gt;

&lt;h3 id=&quot;elided-lifetime-in-path&quot;&gt;Elided Lifetime in Path&lt;/h3&gt;

&lt;p&gt;It is often desirable to omit specification of lifetimes in places where there do not
exist meaningful constraints against them. To support this, and make writing Rust
programs simpler, Rust permits elision of lifetimes, and will apply a set of rules for
filling in lifetime information.&lt;/p&gt;

&lt;p&gt;However, the elision of lifetimes comes with a tradeoff, as it may no longer be clear
when a data type contains references. Given that references must obey a restriction of
aliasing XOR mutability, not knowing a type contains references may lead one to writing
code which violates those restrictions unintentionally, and is therefore rejected by
the compiler.&lt;/p&gt;

&lt;p&gt;This lint disallows lifetime elision in paths, requiring consistent clarity on the
presence of borrowed data. It trades off clarity of syntax for clarity of semantics, and
its application is a matter of taste.&lt;/p&gt;

&lt;h3 id=&quot;missing-copy-implementations&quot;&gt;Missing Copy Implementations&lt;/h3&gt;

&lt;aside id=&quot;aside-1&quot;&gt;
    &lt;h4&gt;Aside #1: When to Implement &lt;code&gt;Copy&lt;/code&gt; &lt;a href=&quot;#aside-1&quot; class=&quot;aside-link&quot;&gt;&lt;span&gt;↺&lt;/span&gt;&lt;/a&gt;&lt;/h4&gt;
    
&lt;p&gt;You may also consider the performance implications of implementing &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt;, which by
definition is implemented as a &lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy&lt;/code&gt; of the bytes containing the type. If the size
of the type is larger than the size of a pointer on the host architecture (a &lt;code class=&quot;highlighter-rouge&quot;&gt;usize&lt;/code&gt;),
then the cost of copying the type will be higher than the cost of copying a pointer to
the type (which is what’s passed when working with references).&lt;/p&gt;

&lt;/aside&gt;

&lt;p&gt;In general, it is considered good Rust practice to implement common traits like &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt;
for types which are able to implement them. This recommendation is enshrined in the
Rust API guidelines, and is intended to make types provided by Rust crates usable
in as wide a variety of contexts as possible.&lt;/p&gt;

&lt;p&gt;This lint helps make sure you don’t forget to implement &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt;, one of the simpler
and more useful common traits, when possible.&lt;/p&gt;

&lt;p&gt;However, there are a couple important notes to make. First, there are types which
one may &lt;em&gt;not&lt;/em&gt; want to implement &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt; for. For example, a type which is designed
to generate monotonically increasing ID numbers probably should not be copied,
lest you end up with two generators generating duplicate IDs. Second, there is a
cost in compile times for generating trait implementations, and so removing
excess trait impls may be desirable for reducing the compilation time of a crate.&lt;/p&gt;

&lt;aside id=&quot;aside-2&quot;&gt;
    &lt;h4&gt;Aside #2: The &lt;code&gt;Copy&lt;/code&gt; Restriction &lt;a href=&quot;#aside-2&quot; class=&quot;aside-link&quot;&gt;&lt;span&gt;↺&lt;/span&gt;&lt;/a&gt;&lt;/h4&gt;
    
&lt;p&gt;When you implement &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt; for a type, you place a restriction on future changes to
that type. &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt; may only be implemented for types without interior pointers, so
implementing &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt; in a public API is a promise the type will not contain pointers
in the future. Removing a trait is always a breaking change, so be aware of the
commitment you’re making when implementing &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt; for a public type.&lt;/p&gt;

&lt;/aside&gt;

&lt;p&gt;In cases where a particular type ought not to be copied, or where the cost of deriving
excess traits is too high, you may assign an item attribute which selectively sets this
lint to &lt;code class=&quot;highlighter-rouge&quot;&gt;allow&lt;/code&gt;. Ideally, this would be accompanied by a comment explaining the
reasoning behind the exception.&lt;/p&gt;

&lt;h3 id=&quot;missing-debug-implementations&quot;&gt;Missing Debug Implementations&lt;/h3&gt;

&lt;p&gt;The same that could be said for the last lint may be said about this one. &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt;
is a common and useful trait that may, as the name suggests, be used to debug
Rust programs by viewing the internals of the types for which it is implemented.&lt;/p&gt;

&lt;aside id=&quot;aside-3&quot;&gt;
    &lt;h4&gt;Aside #3: &lt;code&gt;Debug&lt;/code&gt; for Secrets &lt;a href=&quot;#aside-3&quot; class=&quot;aside-link&quot;&gt;&lt;span&gt;↺&lt;/span&gt;&lt;/a&gt;&lt;/h4&gt;
    
&lt;p&gt;Another option when dealing with &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt; for secret data is to implement it manually
in a manner that doesn’t print the secret. That way it doesn’t interfere with types
which contain it and want to implement &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt;, but also avoids the risk of accidental
disclosure.&lt;/p&gt;

&lt;/aside&gt;

&lt;p&gt;However, there are some types which ought &lt;em&gt;not&lt;/em&gt; to implement &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt;, the most
notable of which are any types which contain secret data. If a type representing
a cryptographic key implements &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt;, it may end up accidentally being printed
to a log or some other location, where an attacker may be able to read it.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Debug&lt;/code&gt;, same as &lt;code class=&quot;highlighter-rouge&quot;&gt;Copy&lt;/code&gt;, also comes with a compilation-time cost which may not
be desirable. This tradeoff ought to be assessed contextually.&lt;/p&gt;

&lt;h3 id=&quot;missing-docs&quot;&gt;Missing Docs&lt;/h3&gt;

&lt;p&gt;Rust makes it easy to create API documentation using the &lt;code class=&quot;highlighter-rouge&quot;&gt;rustdoc&lt;/code&gt; tool, and
ideally all publicly-exposed parts of a crate’s API will receive some degree of
documentation. This lint helps ensure that, although it says nothing about the
&lt;em&gt;quality&lt;/em&gt; of the documentation provided.&lt;/p&gt;

&lt;p&gt;Consider this lint an often necessary but never sufficient part of writing
high-quality documentation for Rust crates.&lt;/p&gt;

&lt;h3 id=&quot;single-use-lifetimes&quot;&gt;Single Use Lifetimes&lt;/h3&gt;

&lt;p&gt;If a lifetime appears in only one places, there’s a question of why it’s there
at all. The goal of well-written lifetime constraints in functions or struct
definitions is to make clear what the constraints are, by eliminating
lifetimes which do not need to be explicitly named. This lint is designed to
catch this case, making it easier to write expressive lifetimes.&lt;/p&gt;

&lt;h3 id=&quot;trivial-casts&quot;&gt;Trivial Casts&lt;/h3&gt;

&lt;p&gt;Some casts aren’t necessary, and could instead be replaced with type coercion,
possibly or optionally with type ascription to specify the new coerced type,
which is considered better style. This lint catches such unecessary casts.&lt;/p&gt;

&lt;h3 id=&quot;trivial-numeric-casts&quot;&gt;Trivial Numeric Casts&lt;/h3&gt;

&lt;p&gt;Similarly, some casts between numeric types aren’t necessary, and will be
flagged by this lint.&lt;/p&gt;

&lt;div class=&quot;box box--info&quot;&gt;
    &lt;header class=&quot;box-header&quot;&gt;
        &lt;h4 class=&quot;box-title&quot;&gt;&lt;!-- Generated by IcoMoon.io --&gt;
&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;32&quot; height=&quot;32&quot; viewBox=&quot;0 0 32 32&quot;&gt;
&lt;title&gt;note&lt;/title&gt;
&lt;path d=&quot;M29.395 2.58c-1.645-1.643-3.811-2.58-5.946-2.58-1.801 0-3.459 0.668-4.67 1.877l-4.867 4.904c-0.015 0.014-0.032 0.023-0.047 0.038-0.008 0.008-0.013 0.019-0.021 0.026l0.002 0.002-10.329 10.409c-0.476 0.473-0.821 1.062-1.013 1.705l-2.349 8.508c-0.002 0.023-0.155 0.691-0.155 1.031 0 1.932 1.569 3.5 3.504 3.5 0.385 0 1.13-0.184 1.157-0.188l8.478-2.229c0.644-0.191 1.229-0.539 1.705-1.016l15.263-15.383c2.776-2.778 2.463-7.434-0.712-10.604zM16.014 23.795c-0.082-0.902-0.337-1.787-0.719-2.627l9.455-9.454c0.578 1.826 0.281 3.736-0.986 5.004-0.008 0.008-0.018 0.013-0.025 0.021l0.014 0.013-7.728 7.79c0-0.249 0.012-0.493-0.011-0.747zM14.793 20.256c-0.373-0.613-0.797-1.205-1.322-1.729-0.611-0.611-1.312-1.090-2.044-1.492l9.532-9.532c0.748 0.332 1.465 0.805 2.098 1.438 0.541 0.539 0.959 1.143 1.281 1.771l-9.545 9.544zM10.486 16.562c-0.926-0.373-1.896-0.586-2.868-0.599l7.703-7.762c1.179-1.15 2.896-1.481 4.587-1.062l-9.422 9.423zM4.167 29.873c-0.109 0.025-0.448 0.111-0.678 0.127-0.822-0.010-1.489-0.678-1.489-1.5 0.012-0.168 0.079-0.457 0.102-0.562l1.053-3.814c1.143-0.031 2.373 0.414 3.34 1.383 0.982 0.98 1.444 2.234 1.394 3.391l-3.722 0.975zM8.874 28.637c-0.024-1.342-0.57-2.738-1.672-3.838-1.042-1.043-2.406-1.645-3.766-1.699l0.996-3.607c0.072-0.24 0.215-0.477 0.391-0.684 2.006-1.436 5.091-1.012 7.234 1.133 2.267 2.266 2.617 5.586 0.871 7.568-0.116 0.061-0.233 0.119-0.359 0.156l-3.695 0.971zM28.691 11.772l-1.684 1.697c0-0.226 0.027-0.443 0.006-0.674-0.176-1.935-1.078-3.806-2.543-5.269-1.629-1.63-3.789-2.565-5.928-2.571l1.656-1.67c0.829-0.827 1.986-1.285 3.251-1.285 1.609 0 3.262 0.728 4.533 1.995 1.193 1.191 1.904 2.671 2.006 4.168 0.094 1.397-0.367 2.678-1.297 3.609z&quot;&gt;&lt;/path&gt;
&lt;/svg&gt;
 A Useful Supplementary Lint&lt;/h4&gt;
    &lt;/header&gt;
    &lt;div class=&quot;box-body&quot;&gt;
        &lt;div class=&quot;box-content&quot;&gt;
            
&lt;p&gt;Clippy offers a useful lint called &lt;a href=&quot;https://rust-lang.github.io/rust-clippy/master/index.html#cast_lossless “Documentation for the cast_lossless Clippy lint”&quot;&gt;“cast lossless”&lt;/a&gt;,
which flags uses of &lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;-conversions which could be replaced by generally
clearer and safer &lt;code class=&quot;highlighter-rouge&quot;&gt;Into&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;From&lt;/code&gt;-conversions which, unlike &lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;-conversions,
are guaranteed to be lossless.&lt;/p&gt;


        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&quot;unreachable-pub&quot;&gt;Unreachable Pub&lt;/h3&gt;

&lt;p&gt;The use of &lt;code class=&quot;highlighter-rouge&quot;&gt;pub&lt;/code&gt; in Rust is to declare an item as public, but if the item’s
containing module is private, the item will itself be private, regardless
of the visibility specified on it directly. This lint helps to catch these
cases, which left unchecked may lead to confusion about visibility when
reading a program’s source code.&lt;/p&gt;

&lt;h3 id=&quot;unsafe-code&quot;&gt;Unsafe Code&lt;/h3&gt;

&lt;p&gt;Unsafe code is an important part of Rust, but it’s not always desirable
to write yourself. Writing correct unsafe code requires care and attentiveness,
and may not be worth the effort for individual projects. To ensure no
unsafe code is currently present, and limit its introduction in the future,
use this lint.&lt;/p&gt;

&lt;h3 id=&quot;unused-extern-crates&quot;&gt;Unused Extern Crates&lt;/h3&gt;

&lt;p&gt;Rust 2018 substantially reduced the need to specify external crates explicitly
in source code, but there remain reasons to do so. If an extern crate is unused,
this lint will catch and report it.&lt;/p&gt;

&lt;h3 id=&quot;unused-import-braces&quot;&gt;Unused Import Braces&lt;/h3&gt;

&lt;p&gt;This is a simple syntactic lint to eliminate braces in imports when used around
a single name, as they aren’t necessary.&lt;/p&gt;

&lt;h3 id=&quot;unused-qualifications&quot;&gt;Unused Qualifications&lt;/h3&gt;

&lt;p&gt;This lint catches when a name is referenced with unnecessary qualification. If a
path has already been imported, then it’s no longer necessary to use the entire
path to items in that name.&lt;/p&gt;

&lt;h3 id=&quot;unused-results&quot;&gt;Unused Results&lt;/h3&gt;

&lt;p&gt;Results are Rust’s core mechanism for reporting and handling errors, and as such
it is strongly recommended to check the values of results when they’re returned.&lt;/p&gt;

&lt;p&gt;If a situation exists where you feel confident that a result does not need to be
checked, you can selectively turn off the lint, ideally with a comment explaining
why you believe it’s acceptable not to check the results contained in the function.&lt;/p&gt;

&lt;h3 id=&quot;variant-size-differences&quot;&gt;Variant Size Differences&lt;/h3&gt;

&lt;p&gt;Enums are as large as their largest variant, so if an enum has one variant which is
substantially larger than the rest, then all uses of the enum will end up with
substantial amounts of wasted space. This lint catches this case, and offers
recommendations to reduce the size of the large variant.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Not all of these will make sense for your code at all, or may not make sense for
the moment. Rejecting missing documentation isn’t worthwhile when you’re just
starting out and aren’t prepared to write documentation for code which is highly
subject to change. Some of these are no longer as useful with modern Rust,
or are only useful in limited contexts.&lt;/p&gt;

&lt;p&gt;That said, lints like the unused copy or debug implementation lints are generally
useful, even if you selectively ignore them in specific cases. As a default,
deriving these traits for libraries is good. In binaries, you may not care as
much.&lt;/p&gt;

&lt;p&gt;Whether you use them or not, it’s useful to be aware that these lints exist!&lt;/p&gt;

&lt;div class=&quot;box box--correction&quot;&gt;
    &lt;header class=&quot;box-header&quot;&gt;
        &lt;h4 class=&quot;box-title&quot;&gt;&lt;!-- Generated by IcoMoon.io --&gt;
&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;32&quot; height=&quot;32&quot; viewBox=&quot;0 0 32 32&quot;&gt;
&lt;title&gt;file&lt;/title&gt;
&lt;path d=&quot;M29.363 4.637c3.516 3.514 3.516 9.213 0 12.727l-10.967 10.968c-0.391 0.392-1.023 0.392-1.414 0-0.393-0.391-0.393-1.022 0-1.414l10.826-10.827c2.734-2.734 2.734-7.164-0.002-9.899-2.73-2.734-7.164-2.734-9.898 0l-14.447 14.277c-1.953 1.952-1.953 5.118 0 7.070 1.953 1.953 5.117 1.953 7.070 0l14.59-14.417c1.17-1.17 1.17-3.073 0-4.243s-3.072-1.169-4.242 0l-10.969 10.969c-0.391 0.391-1.023 0.391-1.414 0-0.391-0.392-0.391-1.023 0-1.415l10.968-10.968c1.951-1.952 5.117-1.952 7.070 0s1.953 5.118 0 7.071l-14.59 14.418c-2.728 2.729-7.169 2.729-9.898 0s-2.729-7.171 0-9.9l14.59-14.417c3.514-3.516 9.213-3.516 12.727 0z&quot;&gt;&lt;/path&gt;
&lt;/svg&gt;
 Corrections&lt;/h4&gt;
    &lt;/header&gt;
    &lt;div class=&quot;box-body&quot;&gt;
        &lt;div class=&quot;box-content&quot;&gt;
            
&lt;h3 id=&quot;anonymous-parameters-arent-allowed-in-rust-2018&quot;&gt;Anonymous Parameters Aren’t Allowed in Rust 2018&lt;/h3&gt;

&lt;p&gt;In the initial version of the post I incorrectly described the state of anomyous
parameters in modern Rust. While such parameters are poor style in Rust 2015, they
are not permitted at all in Rust 2018.&lt;/p&gt;

&lt;h3 id=&quot;bare-trait-objects-now-a-warning-in-both-editions&quot;&gt;Bare Trait Objects Now a Warning in Both Editions&lt;/h3&gt;

&lt;p&gt;In the initial version of this post I incorrectly described the current state of the
bare trait object lint as being allowed by default. In fact, this lint is now set to
warn by default in both Rust 2015 and 2018, and has therefore been removed from
this post.&lt;/p&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</content><author><name>{&quot;picture&quot;=&gt;&quot;/assets/img/me.png&quot;, &quot;twitter&quot;=&gt;&quot;alilleybrinker&quot;}</name></author><category term="Lints" /><summary type="html">The Rust compiler ships with a number of useful lints on by default, and many use Clippy to provide additional lints. It’s less well known that the Rust compiler ships with some useful lints which are set to allow by default, meaning they don’t generate warnings. In this post, I’ll explain what each of these lints does, and why it might be useful.</summary></entry></feed>