<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://www.possiblerust.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.possiblerust.com/" rel="alternate" type="text/html" /><updated>2020-08-05T19:17:26-07:00</updated><id>https://www.possiblerust.com/feed.xml</id><title type="html">Possible Rust</title><subtitle>Learning what&amp;rsquo;s possible in Rust.</subtitle><author><name>Andrew Lilley Brinker</name></author><entry><title type="html">Inbound &amp;amp; Outbound FFI</title><link href="https://www.possiblerust.com/guide/inbound-outbound-ffi" rel="alternate" type="text/html" title="Inbound &amp; Outbound FFI" /><published>2020-08-05T18:10:00-07:00</published><updated>2020-08-05T18:10:00-07:00</updated><id>https://www.possiblerust.com/guide/inbound-outbound-ffi</id><author><name>Andrew Lilley Brinker</name></author><category term="FFI" /><summary type="html">Foreign Function Interfaces (FFI) are a core mechanism for enabling integration of new languages into existing codebases or building on existing libraries. That said, the term “FFI” is often overloaded in ways that may be unclear or ambiguous, and the area can seem overwhelming to approach. In this post, I explain the two “directions” of FFI, some patterns for how FFI in each direction is handled in Rust and further break down some FFI design approaches.</summary></entry><entry><title type="html">Enum or Trait Object</title><link href="https://www.possiblerust.com/guide/enum-or-trait-object" rel="alternate" type="text/html" title="Enum or Trait Object" /><published>2020-07-27T17:53:00-07:00</published><updated>2020-07-27T17:53:00-07:00</updated><id>https://www.possiblerust.com/guide/enum-or-trait-object</id><author><name>Andrew Lilley Brinker</name></author><category term="Enums" /><category term="Trait Objects" /><summary type="html">Rust has two major mechanisms for delegating logic: enums and trait objects, and it may be unclear when to use one or the other. In this post, I will walk through how each works, what the tradeoffs are, and how to choose the right option for your code.</summary></entry><entry><title type="html">Rust Lints You May Not Know</title><link href="https://www.possiblerust.com/pattern/rust-lints-you-may-not-know" rel="alternate" type="text/html" title="Rust Lints You May Not Know" /><published>2020-06-21T15:59:00-07:00</published><updated>2020-06-21T15:59:00-07:00</updated><id>https://www.possiblerust.com/pattern/rust-lints-you-may-not-know</id><author><name>Andrew Lilley Brinker</name></author><category term="Lints" /><summary type="html">The Rust compiler ships with a number of useful lints on by default, and many use Clippy to provide additional lints. It’s less well known that the Rust compiler ships with some useful lints which are set to allow by default, meaning they don’t generate warnings. In this post, I’ll explain what each of these lints does, and why it might be useful.</summary></entry></feed>